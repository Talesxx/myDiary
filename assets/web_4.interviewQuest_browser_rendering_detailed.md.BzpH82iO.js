import{_ as a,o as i,c as e,a3 as r}from"./chunks/framework.C3ayHplB.js";const u=JSON.parse('{"title":"浏览器渲染流程详解","description":"","frontmatter":{},"headers":[],"relativePath":"web/4.interviewQuest/browser_rendering_detailed.md","filePath":"web/4.interviewQuest/browser_rendering_detailed.md"}'),t={name:"web/4.interviewQuest/browser_rendering_detailed.md"};function n(d,l,o,h,s,c){return i(),e("div",null,[...l[0]||(l[0]=[r('<h1 id="浏览器渲染流程详解" tabindex="-1">浏览器渲染流程详解 <a class="header-anchor" href="#浏览器渲染流程详解" aria-label="Permalink to “浏览器渲染流程详解”">​</a></h1><h2 id="完整的浏览器渲染过程" tabindex="-1">完整的浏览器渲染过程 <a class="header-anchor" href="#完整的浏览器渲染过程" aria-label="Permalink to “完整的浏览器渲染过程”">​</a></h2><h3 id="_1-用户输入-url" tabindex="-1">1. 用户输入 URL <a class="header-anchor" href="#_1-用户输入-url" aria-label="Permalink to “1. 用户输入 URL”">​</a></h3><ul><li>用户在地址栏输入URL或点击链接</li><li>浏览器检测输入内容并确定协议（HTTP/HTTPS等）</li><li>如果输入的是搜索词而非URL，浏览器会使用默认搜索引擎进行查询</li></ul><h3 id="_2-dns-解析" tabindex="-1">2. DNS 解析 <a class="header-anchor" href="#_2-dns-解析" aria-label="Permalink to “2. DNS 解析”">​</a></h3><ul><li>浏览器首先检查自身缓存中是否有对应域名的IP地址</li><li>如未找到，则向操作系统发起查询</li><li>若操作系统也无记录，则向DNS服务器发送请求</li><li>递归解析直到获得目标服务器的IP地址</li></ul><h3 id="_3-tcp-连接-tls-握手" tabindex="-1">3. TCP 连接 + TLS 握手 <a class="header-anchor" href="#_3-tcp-连接-tls-握手" aria-label="Permalink to “3. TCP 连接 + TLS 握手”">​</a></h3><ul><li>建立TCP连接（三次握手）</li><li>对于HTTPS请求，进行TLS握手： <ul><li>客户端发送支持的TLS版本和加密算法</li><li>服务器返回数字证书和选择的加密算法</li><li>客户端验证证书有效性</li><li>双方协商生成会话密钥</li></ul></li></ul><h3 id="_4-发送-http-请求" tabindex="-1">4. 发送 HTTP 请求 <a class="header-anchor" href="#_4-发送-http-请求" aria-label="Permalink to “4. 发送 HTTP 请求”">​</a></h3><ul><li>浏览器构建HTTP请求报文</li><li>包括请求行、请求头、请求体</li><li>通过TCP连接发送到服务器</li></ul><h3 id="_5-接收-html-响应" tabindex="-1">5. 接收 HTML 响应 <a class="header-anchor" href="#_5-接收-html-响应" aria-label="Permalink to “5. 接收 HTML 响应”">​</a></h3><ul><li>服务器处理请求并返回HTML文档</li><li>浏览器接收响应数据</li><li>检查HTTP状态码确认请求成功</li></ul><h3 id="_6-解析-html-→-构建-dom" tabindex="-1">6. 解析 HTML → 构建 DOM <a class="header-anchor" href="#_6-解析-html-→-构建-dom" aria-label="Permalink to “6. 解析 HTML → 构建 DOM”">​</a></h3><ul><li>浏览器开始解析HTML标记</li><li>构建DOM树（Document Object Model）</li><li>DOM树代表页面的结构化内容</li><li>在解析HTML的过程中，遇到外部资源（如CSS、图片）会并行加载，但遇到script标签（没有async/defer属性）时会阻塞解析，先下载并执行JS。</li></ul><h3 id="_7-加载-css-→-构建-cssom" tabindex="-1">7. 加载 CSS → 构建 CSSOM <a class="header-anchor" href="#_7-加载-css-→-构建-cssom" aria-label="Permalink to “7. 加载 CSS → 构建 CSSOM”">​</a></h3><ul><li>解析HTML过程中发现CSS资源（link标签、style标签、内联样式）</li><li>下载并解析CSS规则</li><li>构建CSSOM树（CSS Object Model）</li><li>CSSOM树包含所有样式规则</li></ul><h3 id="_8-遇到-script标签-→-执行-js" tabindex="-1">8. 遇到 script标签 → 执行 JS <a class="header-anchor" href="#_8-遇到-script标签-→-执行-js" aria-label="Permalink to “8. 遇到 script标签 → 执行 JS”">​</a></h3><ul><li>解析HTML过程中遇到script标签</li><li>默认情况下，脚本下载和执行会阻塞HTML解析</li><li>可通过async或defer属性改变行为</li><li>JavaScript可以修改DOM和CSSOM</li></ul><h3 id="_9-构建-render-tree" tabindex="-1">9. 构建 Render Tree <a class="header-anchor" href="#_9-构建-render-tree" aria-label="Permalink to “9. 构建 Render Tree”">​</a></h3><ul><li>结合DOM树和CSSOM树</li><li>创建渲染树（Render Tree）</li><li>渲染树只包含视觉信息相关的节点（非display:none或head元素）</li></ul><h3 id="_10-layout-布局" tabindex="-1">10. Layout 布局 <a class="header-anchor" href="#_10-layout-布局" aria-label="Permalink to “10. Layout 布局”">​</a></h3><ul><li>计算渲染树中每个节点的精确位置和大小</li><li>这个过程也称为重排（Reflow）</li><li>确定页面上每个元素的确切位置</li></ul><h3 id="_11-paint-绘制" tabindex="-1">11. Paint 绘制 <a class="header-anchor" href="#_11-paint-绘制" aria-label="Permalink to “11. Paint 绘制”">​</a></h3><ul><li>将渲染树中的每个节点转换为屏幕上的实际像素</li><li>创建视觉层（Visual Layers）</li><li>执行绘制操作，填充颜色、绘制文本、图像等</li></ul><h3 id="_12-composite-合成" tabindex="-1">12. Composite 合成 <a class="header-anchor" href="#_12-composite-合成" aria-label="Permalink to “12. Composite 合成”">​</a></h3><ul><li>将多个图层按照正确的层级顺序合成</li><li>利用GPU加速提高性能</li><li>将最终画面呈现给用户</li></ul><h3 id="_13-domcontentloaded" tabindex="-1">13. DOMContentLoaded <a class="header-anchor" href="#_13-domcontentloaded" aria-label="Permalink to “13. DOMContentLoaded”">​</a></h3><ul><li>DOM文档完全加载和解析完成</li><li>不等待样式表、图像等资源加载</li><li>此时可以安全地访问DOM元素</li></ul><h3 id="_14-页面可见-几乎和domcontentloaded同步" tabindex="-1">14. 页面可见（几乎和DOMContentLoaded同步） <a class="header-anchor" href="#_14-页面可见-几乎和domcontentloaded同步" aria-label="Permalink to “14. 页面可见（几乎和DOMContentLoaded同步）”">​</a></h3><ul><li>页面内容首次在屏幕上显示</li><li>用户可以看到部分或全部内容</li></ul><h3 id="_15-load" tabindex="-1">15. Load <a class="header-anchor" href="#_15-load" aria-label="Permalink to “15. Load”">​</a></h3><ul><li>页面所有资源（包括图片、样式表等）完全加载完成</li><li>window.onload事件触发</li></ul><h3 id="_16-用户可交互" tabindex="-1">16. 用户可交互 <a class="header-anchor" href="#_16-用户可交互" aria-label="Permalink to “16. 用户可交互”">​</a></h3><ul><li>所有资源加载完成</li><li>所有初始化脚本执行完毕</li><li>用户可以与页面完全交互</li></ul><h2 id="性能优化建议" tabindex="-1">性能优化建议 <a class="header-anchor" href="#性能优化建议" aria-label="Permalink to “性能优化建议”">​</a></h2><ol><li><strong>关键渲染路径优化</strong>：减少关键资源数量，降低字节大小，缩短往返时间</li><li><strong>CSS优化</strong>：避免CSS阻塞，使用媒体查询条件加载</li><li><strong>JavaScript优化</strong>：合理使用async/defer，避免长时间运行脚本</li><li><strong>资源预加载</strong>：使用preload、prefetch等技术优化资源加载</li><li><strong>缓存策略</strong>：合理设置HTTP缓存头，利用浏览器缓存机制</li></ol><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to “注意事项”">​</a></h2><ul><li>某些步骤可能会因资源异步加载而重新执行</li><li>动态内容更新可能导致部分渲染流程重复执行</li><li>现代浏览器使用各种优化技术（如预解析、预测加载等）提升性能</li></ul>',38)])])}const b=a(t,[["render",n]]);export{u as __pageData,b as default};
